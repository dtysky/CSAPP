# 2-数的表示与运算

## 整形

整形数据顾名思义，是指`整数`，整数在计算机中的表示是精确的，也是有限的。一般而言，如果一个整数的位宽为`w`，则其表示的无符号整数所能表示数的范围为`$0 \sim 2^w-1$`，而有符号整数则能表示`$-2^{w/2} \sim 2^{w/2}-1$`。比如，对于一个32位的系统，其`int`型有符号整数的位宽是32，所以其范围是`-2147483648 ~ 2147483647`。  

C中的整形数据类型一般有`char`、`short`、`int`、`long`、`long long`，位宽逐级递增，具体位宽取决于系统，在这些类型前加上`unsigned`便可以定义一个无符号数。  

>再次声明注意，在依赖于通信的应用中，字节序和位宽的匹配是**特别重要**的，如果可以，尽量使用c++中的`stdint`中的类型，或者自己定义一些`uint_8t`之类的类型。  

### 编码

整数的编码可以区分为有符号和无符号两种，无符号编码整数对应的值即为其二进制对应的值，无需多言。有符号编码整数对应的值，一般是其二进制对应的补码。  
补码是一种表示有符号数的编码形式，对于一个n位的有符号数A，其最高位为符号位，为1表示负数，为0表示正数，其他位为数值位。当A为正数时，数值位对应的二进制数即为A所代表的值，比如`0111`所代表的有符号数为`7`；A为负数时，数值位对应的二进制数的补码加上负号为A的值，比如`1111`表示`-1`。其计算规则为：  

>A的补码 = A的取反加1。比如当`A = 111`时，其补码为`000 + 1 = 001`。  

当然，这并非最简单和最原始的算法，书中给出的方法是，对于有符号数`A = abcd`，其中abcd均为0或者1：  

$$A = -a\*2^3 + b\*2^2 + c\*2 + d $$

除了补码之外，有符号数的表示方式还有反码和原码，反码即为补码减1，而原码即为将数值位直接作为其绝对值的负数。在整数的表示形式中，这二者除了在某些底层硬件应用外并不常用，不再过多讨论。需要注意的是这二者的`0`都有`+0`和`-0`两种形式。  

>补码的英文为`Two's complement`，反码为`Ones' complement`。我们可以用`$2^w - x$`来计算一个位宽w并且原码为x的数的补码，可以用`$2^w\{1\} - x$`来计算其反码。  

### 转换

C中有符号数和无符号的转换在不同基础的计算机上不同，但都遵循同样的原则——不改变其最底层的字节本身，而只是改变解释的方式。这样会导致这种转换出现反直觉的结果，比如下面代码：  

    :::c
    int x = -111;
    unsigned int y = (unsigned int)x;
    printf("%u", y);

输出为`4294967185`。  

通过以上定义，不难推出一系列的所谓补码和无符号数转换公式，但目测作用不大。