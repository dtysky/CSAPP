# 2-数的表示与运算

## 整形

整形数据顾名思义，是指`整数`，整数在计算机中的表示是精确的，也是有限的。一般而言，如果一个整数的位宽为`w`，则其表示的无符号整数所能表示数的范围为`$0 \sim 2^w-1$`，而有符号整数则能表示`$-2^{w/2} \sim 2^{w/2}-1$`。比如，对于一个32位的系统，其`int`型有符号整数的位宽是32，所以其范围是`-2147483648 ~ 2147483647`。  

C中的整形数据类型一般有`char`、`short`、`int`、`long`、`long long`，位宽逐级递增，具体位宽取决于系统，在这些类型前加上`unsigned`便可以定义一个无符号数。  

>再次声明注意，在依赖于通信的应用中，字节序和位宽的匹配是**特别重要**的，如果可以，尽量使用c++中的`stdint`中的类型，或者自己定义一些`uint_8t`之类的类型。  

### 编码

整数的编码可以区分为有符号和无符号两种，无符号编码整数对应的值即为其二进制对应的值，无需多言。有符号编码整数对应的值，一般是其二进制对应的补码。  
补码是一种表示有符号数的编码形式，对于一个n位的有符号数A，其最高位为符号位，为1表示负数，为0表示正数，其他位为数值位。当A为正数时，数值位对应的二进制数即为A所代表的值，比如`0111`所代表的有符号数为`7`；A为负数时，数值位对应的二进制数的补码加上负号为A的值，比如`1111`表示`-1`。其计算规则为：  

>A的补码 = A的取反加1。比如当`A = 111`时，其补码为`000 + 1 = 001`。  

当然，这并非最简单和最原始的算法，书中给出的方法是，对于有符号数`A = abcd`，其中abcd均为0或者1：  

$$A = -a\*2^3 + b\*2^2 + c\*2 + d $$

除了补码之外，有符号数的表示方式还有反码和原码，反码即为补码减1，而原码即为将数值位直接作为其绝对值的负数。在整数的表示形式中，这二者除了在某些底层硬件应用外并不常用，不再过多讨论。需要注意的是这二者的`0`都有`+0`和`-0`两种形式。  

>补码的英文为`Two's complement`，反码为`Ones' complement`。我们可以用`$2^w - x$`来计算一个位宽w并且原码为x的数的补码，可以用`$2^w\{1\} - x$`来计算其反码。  

### 转换

C中有符号数和无符号的转换在不同基础的计算机上不同，但都遵循同样的原则——不改变其最底层的字节本身，而只是改变解释的方式。这样会导致这种转换出现反直觉的结果，比如下面代码：  

    :::c
    int x = -111;
    unsigned int y = (unsigned int)x;
    printf("%u", y);

输出为`4294967185`。  

通过以上定义，不难推出一系列的所谓补码和无符号数转换公式，但目测作用不大。

### 在C中

#### 转换

C中的基础数据类型转换可以显示进行，也可以隐式进行。前者表现为`float y = (float) x;`这样的语句，其中`x`是`int`型变量；后者的表现则丰富的多，有`float y = x;`这种，也有在格式化输出时的`printf("%u", x);`这种，他会把`int`型变量`x`转换为无符号数输出。  

在运算中，如果一个数是有符号而另一个为无符号的，则有符号数会被隐式转换为无符号数，这体现在加减乘除个各种比较运算中，比如：  

    :::c
    int x = -1;
    unsigned int y = 0;
    printf("%d", x < y);
    
得到的结果是`0`，即`false`，因为此时x被当做无符号数处理了，是一个很大的正数。  

在标准库文件`limits.h`中定义了`int`的最大和最小值，其中：  

    :::c
    #define INT_MIN (-INT_MAX - 1)
    
这是由于一些比较隐晦的原因。

#### 扩展和截断

数的`位扩展`一般发生在不同字长的整数的转换时，例如当一个整数从`char`型转换为`int`型时，就需要将8bits的数转换为32bits（在32bits的系统下）。对于无符号数，直接将低八位保留，高八位补零即可，但对于有符号数，则需要根据符号位的情况选择补零还是补一。

数的`截断`类似于`扩展`，不过与后者相反。截断在位级对于有符号数和无符号数都是相同的，都是高位裁剪，但结果还保留着原先的性质，无需多说。  

