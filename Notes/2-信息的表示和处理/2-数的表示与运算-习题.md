# 2-数的表示与运算-习题

所有有代码的练习都以以题号为名字的单个文件内。  

代码位于[CSAPP-Chapter2](https://github.com/dtysky/CSAPP/tree/master/CSAPP/Chapter2)内。

### 17

基础计算，略过。  

### 18

A: 0b0000000110111000 = 440  
B: 0b0000000000010100 = 20  
C: 0b1111111001011000 = - (0b0000000110100111 + 1) = -424  
......  

### 19

将十进制的二进制补码表示按照二进制无符号数解释即可。

### 20

比如对于`-8`，其补码为`1000`，位宽`w = 4`，所以，补码转换为无符号数的结果为`$-8 + 2^4 = 8$`，结果和直接将二进制解释为无符号数时一致。  

### 21

只需要注意有符号数和无符号是在计算式会被隐式转换为无符号数即可。  

### 22

对于A：  

$$x = -1 \* 2^3 + 1 \* 2 + 1 \* 1 = -5$$  

对于其他也一样。  

### 23

`fun1`先对`word`左移24位，再逻辑右移24位，之后转换为有符号数。  
`fun2`先将`word`转换为有符号数，之后左移24位，再算术右移24位。  

|w|fun1(2)|fun2(w)|
|-|-------|-------|
|0x00000076|0x00000076|0x00000076|
|0x87654321|0x00000021|0x00000021|
|0x000000c9|0x000000c9|0xffffffc9|
|0xedcba987|0x00000087|0xffffff87|

### 24

位级去掉最高位，将剩余解释为有符号或者无符号数即可。  

### 25

详见代码。  

当数组长度为0时，由于`length`为无符号数，所以`length - 1`语句将得到一个无符号数的结果，在32bits的机器上，此结果为`0xffffffff`对应的无符号数，是一个很大的正数。所以在循环时，会有数组越界发生，即访问未初始化的存储区域，发生错误。  

将`i <= length - 1`改为`i < length`可破。

### 26

详见代码。  

`size_t`为无符号数，`s`与`t`的长度的相减也会的到一个无符号结果，这使得改结果与0相比较大或相等，无法得到正确结果。  
将相减后与0比较直接改为两个长度相比较即可。  

### 27

比较x + y 和 x（或y）的大小即可。

### 28

套公式，略过。  

### 29

基础计算，略过。  

### 30

详见代码。  

溢出只有可能在`x`和`y`同号时出现，都为正时可能发生正溢出，即最终和为负，都为负时则可能发生负溢出，即和最终为正。

### 31

溢出是可逆的，即便`sum`溢出了，但`sum - x = y`却还是成立的。  

### 32

因为补码的值域不是关于y轴对称的，所以当`y`为`INT_MIN`时，`-y`会直接发生溢出，变为`y`，此时如果`x`为0，题目所示的函数将不会认为溢出，但实际上已经溢出了。  

在原先的代码加一个分支即可。

### 33

0xF的补码是其自身，其他都是相反数。  

### 34

基础运算，略过。

### 35

#### 1

$$B2T\_{2w}(x) = -x\_{2w-1} 2^{2w-1} + x\_{2w-2} 2^{2w-2} + ... + x\_w * 2^2 + \sum\_{i=0}^{w-1}x_i2^i$$  

$$=2^w({-x\_{2w-1} 2^{w-1} + x\_{2w-2} 2^{w-2} + ... + x\_w}) + \sum\_{i=0}^{w-1}x_i2^i$$  

$$=2^w({-x\_{2w-1} 2^{w-1} + \sum\_{i=0}^{w-2} x\_i2^i}) + \sum\_{i=0}^{w-1}x_i2^i$$  

$$=2^wv + u$$  

已知有符号和无符号乘法在位形式上一致，令上述公式的`x=x*y`，其中`p`是乘积`x*y`在w位时的补码形式，则有：  

$$u=p_{w-1}2^w+p$$  

于是有：  

$$x\*y = 2^w(v+p_{w-1})+p$$  

令`$t = v+p_{w-1}$`则：  

$$x\*y = t2^w+p$$  

即证。  

#### 2

由于`p`是一个整数，所以其总是可以被分解为一个非零整数、商和余数的和，即：  

$$p = xq + r$$  

即证。  

#### 3

令`q=y`，则有：  

$$p = xy + r$$  

而`$p=xy-t2^w$`，固有：  

$$r=-t2^w$$  

由于`r`的绝对值小于`x`的绝对值，而`x`又是一个补码，所以`x`的最大值为`$2^w$`，同时`t`为一个大于等于1的数，所以要使此等式成立，`r`和`t`都必须为0，即证。

### 36

详见代码。  

#### 37

改进是这段代码的乘法计算部分不再溢出，但由于malloc的最后一个参数是`size_t`，所以还是存在问题的。  

解决方法就是将相乘的两个数都声明为int型，这样它们都为正数时，相乘放入一个`size_t`中时便不会溢出。  
而实际上，这两个值的确都是正数。

#### 38

b为0时，可以计算1、2、3、8倍，为a时，可以计算2、3、5、9倍。  

#### 39

$$(2^{n+1} - 2^m)x = 2^m(2^{n+1-m}-1)x$$  

即：  

> ((x << n+1-m) - x) << m

#### 40

>1. x << 3 - x << 1 
2. x << 5 - x
3. x << 1 - x << 3
4. y = x << 2 + x; y << 1 + y << 3

#### 41

如果n有可能超过位宽，选A。  
否则，选B。

#### 42

详见代码。  

可以使用31位的符号右移确定`x`是正数或者负数，而后使用`mask`得到合适的偏置，最后直接根据公式求解。

#### 43

$$M = 2^6 - 1$$  

$$N = 2^3$$

#### 44

>1. 要使该式为假则必须要找到整数`x`，使得`x-1>=0`且`x<=0`，这样的`x`在C中是存在的，即`x=INT_MIN`，减1运算后会发生溢出。  
2. 若`x&7`为7则`x`的低三位全为1，而`x<<29`大于0则`x`的倒数第3位为0，这样的`x`不存在，所以原式必然为真。  
3. 当结果会溢出的时候，原式便可能为假。  
4. 事实上，整数`x`如果不是负数就是0要么就是正数，并且原式没有特别的边界情况，恒成立。  
5. 与4基本一致，但当`x=INT_MIN`的时候，`-x`由于溢出仍然为`x=INT_MAX`,还是为负，这可以使得原式为假。  
6. 恒成立，C中，当无符号数和有符号数做运算时，会把有符号数转为无符号数，而有符号数和无符号数在位级上运算又是等价的。  
7. `-y=~y+1` -> `~y=-y-1`，所以这个式子本质上和6中的一致，原式成立。