# 2-控制与过程

## 控制

汇编中使用控制语句来实现线性程序之外的跳转、选择等功能。 

### 条件码

**条件码**用于表示一些CPU最近的状态，它们被存在一个单独的**条件寄存器**中，它们是：  

>CF：进位标志，最近操作发生了进位，可以检查无符号数的溢出。  
ZF：零标志，最近操作结果为0。  
SF：符号标志，最近操作的结果为负数。  
OF：溢出标志，最近操作导致补码溢出。  

要注意的是，`lea`系列指令不会不会改变这些标志，因为它本质上不是ALU运算而是地址运算；`inc`和`dec`会设置溢出标志但不会设置进位标志等......   

还有一些特殊的指令只改变条件码而不发生实际运算，比如`test`、`cmp`，前者对应`sub`、后者对应`and`。  

要访问这些条件码，有一系列的`set d`指令被提供，其中`d`是单字节寄存器，这组指令直接利用条件码去做出一些常用的判断，比如`setge d`相当于给`d`赋予`~(SF ^ OF)`，即前一个运算的两个操作数是否存在大于关系。  

### 跳转

跳转指令`jmp .L`和`jmp *e*`会导致程序在执行时切换到另一个位置。前一种方式中，它的参数`L`是一个**标示符**，这个标示符类似于高级语言中的函数名，用于标示一段程序的开始，汇编中就是用这种方式来管理子程序的；后一种方式中，它的参数`e`是一个寄存器或者以寄存器为地址的`(%eax)`这种存储器的值，这些值将会给当做跳转地址。  
还有一些跳转叫做**条件跳转**，它们是基本跳转语句的特化版本，比如`je`就是当`ZF`位为1时跳转之类的。它们也是高级语言条件语句的基础。  

至于C语言的条件语句翻译成汇编，一般都是先开一个条件跳转语句，然后后面更上else的内容。

### 循环

循环语句在C中有`do-while`、`while`和`for`，太基础就不细说了。  

`do-while`它们可以对应汇编中的`goto`和条件跳转指令的组合，像是：  

    :::asm
    loop:
        xxx
        je next
        goto loop

`while`和`do-while`类似，但它的判断放在loop段的开始，这允许产生零长度的循环：  

    :::asm
    loop:
        je next
        xxx
        goto loop
        

`for`一般等价于`while`形式，是另一种写法。但当和`continue`语句合作是可能有例外。详见习题24。

### 条件传送语句

条件传送语句是现代CPU都有的一条指令，它本质上是以下C代码的翻译：  

    :::c
    int absdiff(int x, int y){
        return x < y ? y - x : x - y;
    }
    
在汇编中，会先计算好`y-x`和`x-y`，然后通过一条`cmovl`指令（`l`表示小于）直接判断前面`cmp`的比较结果即条件码然后送走`y-x`或者`x-y`而不是通过条件跳转。  这样做的效率一般会很高，这是由于CPU内部的流水线采用的分支预测机制。因为对于此指令，处理器只是读数据、检查条件码、然后更新或者不动目的寄存器，不会有额外的跳转。  

当然这个指令并非时时有效，由于它要事先计算两个分支的结果，所以可能会造成无谓的计算浪费，也受编译器的影响。  

### switch指令

对应于C中的switch语句，当分支较多并且每个分支的条件间隔较小时，会生成一个**跳转表**，有个这个表，可以使得分支实现和复杂度无关，相对于经典的条件转移，利用查表的方式可以说复杂度都是固定的，是并行判断。  

## 过程

**过程调用**将数据和控制进行跳转，而后又可以恢复现场继续执行刚才的操作。这是通过**转移到控制**和**转移出控制**实现的。  

### 栈帧

**栈帧**实际上就是栈的一种应用，它是为单个过程所分配的栈，由存放于`%ebp`中的帧指针和存放于`%esp`中的栈指针控制。

![栈帧](./iamges/1.png)  

### 转移控制

当一个过程被`call`指令调用时，首先将返回地址入栈，然后当前一些需要保护的局部变量什么的`入栈`，保护现场，随后跳转到被调用过程 的首地址，调用结束后再使用`leave`指令做好准备，之后`ret`指令恢复现场并返回跳转前的地址继续。 

调用控制中的寄存器分配是约定俗成的`%eax`、`%edx`和`ecx`被分配给被调用者，可以被覆盖，而`%ebx`、`%esi`和`%edi`则分配给调用者，再覆盖之前要先入栈以便恢复。  

对于`递归过程`，编译器会将每次函数对自身的调用都视为调用一个其他的函数，本质上并无区别。