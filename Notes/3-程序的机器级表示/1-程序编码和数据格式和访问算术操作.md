# 1-程序编码和数据格式和访问信息和数据操作

计算机执行的是**机器码**，即一条一条的01序列，这些序列经过CPU的**控制译码器**译码后以数字电路的形式操作CPU的其他部件进行工作。但机器码对人的可读性极其差，所以有了**汇编代码**。汇编代码可以看做是机器码的文本表现，十分接近于机器码的原本性质，但其抽象程度过低，难以构建大型工程，所以又有了**C**这样系统级语言，他可读性和抽象性更高，同时不会损失太多性能，但对于日渐膨胀的效率需求，系统及语言很多时候也无法更上迭代的速度，所以便有了**C#**这种编译型的高级语言和**Python**这种解释型的脚本语言，他们比**C**更上层，开发效率更高，门槛更低。但一般而言，开发效率和运行效率是不可兼得的。  

对于C，需要一个**编译器**将其编译到汇编，**汇编器**再将汇编转换为机器码，而不同硬件平台的汇编代码往往有差异，所以高级语言还有一个重要的特点就是帮我们屏蔽了硬件底层，将兼容工作交给工具去做。  

“精通细节是理解更深和更基本概念的先决条件。”  

## 程序编码

在xinx系统中，可以使用以下代码编译一个C文件：  

    :::bash
    gcc -o1 -o p p1.c p2.c
    
编译两个C文件到`p`中，使用第一级优化。优化随着等级上升性能提高，但和原始代码的对应会下降，并且会增加编译时间。  

在编译过程中，编译器文件首先会将代码中的`#include`和`#define`扩展插入代码，然后编译成汇编文件`.s`，随后汇编为机器码`.o`文件，然后和预制库进行连接，生成最后的可执行文件。  

程序中的代码段存储在程序存储器中，比如操作系统信息、运行时栈等，其使用虚拟地址来寻址，操作系统负责将虚拟地址转换成物理地址。  

### 一个例子

如果我们有一段C代码`code.c`，运行`gcc -O1 -S code.c`将其编译为汇编文件后便是`code.s`，其中是这段代码对应的汇编代码，这段代码一般会用`push`指令保护现场，然后执行函数，最后`pop`指令恢复现场。运行`gcc -O1 -c code.s`会得到`code.o`，这是二进制的机器码，其大小很大因为包含了执行开始等附加信息。可以通过反汇编器来从机器码中得到原始函数的字节长度并用`gdb`来检查。  

作为**CISP**，即复杂指令集的CPU，**IA32**和**X86**架构的机器指令长度均不一致，有的长有的短。

## 数据格式

机器中的数据格式和C中的数据类型有一定的对应关系。整形数据格式有8bits的**字节**，16bits的**字**，32bits的**双字**和64bits的**四字**等，浮点数据格式有32bits的**单精度**，64bits的**双精度**和60~72bits的**扩展精度**。这些格式在汇编中拥有各自专属的指令，会在一般指令后加上后缀，比如两个双字相加就是`addl`等。  

对于IA32处理器，由于四字不被直接支持，所以四字的运算和操作会被扩展。  

## 访问信息

新时代的CPU对寄存器的专用性需求不再存在，所以CPU中的寄存器都是通用寄存器，但一般有一种约定，IA32中每一个CPU包含八个32bits的寄存器，有些指令会使用固定的源寄存器和目的寄存器，`eax`、`ecx`、`edx`特殊，`ebp`和`esp`保存栈指针和帧指针，等等。  

每一个指令都有其操作数，一些指令又分为**源操作数**和**目的操作数**，这些操作数可以是**立即数**、**存储器地址**和**寄存器**，对于存储器，可以用许多种方式进行寻址，比如**绝对寻址**、**变址寻址**等，详细请自行查找CPU寻址相关。  

**数据传送**指令将数据从一个位置复制到另一个位置，`mov`系列传送数据，`movs`系列传送符号扩展字节，`movz`系列传送零扩展字节，`push`和`pop`分别压栈和出栈。  

**栈**是一种特殊的数组，遵循先入后出原则，但由于其和一般数据的存储本质上并无不同之处，所以还是也可以使用一般的寻址方式访问其中的任意元素。  

需要注意的是，传送指令的两个操作数不能都为存储器。